"""Interactive production deployment helper for AgBlogger."""

from __future__ import annotations

import argparse
import getpass
import json
import secrets
import shutil
import subprocess
import sys
from contextlib import suppress
from dataclasses import dataclass
from pathlib import Path

MIN_SECRET_KEY_LENGTH = 32
MIN_ADMIN_PASSWORD_LENGTH = 12
DEFAULT_HOST_PORT = 8000
DEFAULT_ENV_FILE = ".env.production"


class DeployError(RuntimeError):
    """Raised for deployment workflow failures."""


@dataclass(frozen=True)
class DeployConfig:
    """User-provided production configuration."""

    secret_key: str
    admin_username: str
    admin_password: str
    trusted_hosts: list[str]
    trusted_proxy_ips: list[str]
    host_port: int


@dataclass(frozen=True)
class DeployResult:
    """Result metadata for a successful deployment."""

    env_path: Path
    commands: dict[str, str]


def parse_csv_list(raw: str) -> list[str]:
    """Parse comma-separated values, trimming whitespace and removing duplicates."""
    values: list[str] = []
    for entry in raw.split(","):
        candidate = entry.strip()
        if candidate and candidate not in values:
            values.append(candidate)
    return values


def _list_to_env_json(values: list[str]) -> str:
    """Serialize list values for pydantic-settings JSON parsing."""
    return json.dumps(values, separators=(",", ":"))


def _quote_env_value(value: str) -> str:
    """Quote scalar env values so special characters stay intact."""
    return json.dumps(value)


def build_env_content(config: DeployConfig) -> str:
    """Build .env file content for production deployment."""
    lines = [
        "# Auto-generated by cli/deploy_production.py",
        f"SECRET_KEY={_quote_env_value(config.secret_key)}",
        f"ADMIN_USERNAME={_quote_env_value(config.admin_username)}",
        f"ADMIN_PASSWORD={_quote_env_value(config.admin_password)}",
        f"HOST_PORT={config.host_port}",
        "HOST=0.0.0.0",
        "PORT=8000",
        "DEBUG=false",
        "EXPOSE_DOCS=false",
        f"TRUSTED_HOSTS={_list_to_env_json(config.trusted_hosts)}",
        f"TRUSTED_PROXY_IPS={_list_to_env_json(config.trusted_proxy_ips)}",
        "AUTH_ENFORCE_LOGIN_ORIGIN=true",
    ]
    return "\n".join(lines) + "\n"


def build_lifecycle_commands(env_filename: str = DEFAULT_ENV_FILE) -> dict[str, str]:
    """Build Docker Compose lifecycle commands shown to the user."""
    base = f"docker compose --env-file {env_filename}"
    return {
        "start": f"{base} up -d",
        "stop": f"{base} down",
        "status": f"{base} ps",
    }


def _validate_config(config: DeployConfig) -> None:
    """Validate required production constraints before writing files."""
    if len(config.secret_key) < MIN_SECRET_KEY_LENGTH:
        raise DeployError(f"SECRET_KEY must have at least {MIN_SECRET_KEY_LENGTH} characters")
    if len(config.admin_password) < MIN_ADMIN_PASSWORD_LENGTH:
        raise DeployError(
            f"ADMIN_PASSWORD must have at least {MIN_ADMIN_PASSWORD_LENGTH} characters"
        )
    if not config.admin_username:
        raise DeployError("ADMIN_USERNAME must not be empty")
    if not config.trusted_hosts:
        raise DeployError("TRUSTED_HOSTS must include at least one host")
    if not (1 <= config.host_port <= 65535):
        raise DeployError("HOST_PORT must be between 1 and 65535")


def check_prerequisites(project_dir: Path) -> None:
    """Check required deployment prerequisites."""
    compose_file = project_dir / "docker-compose.yml"
    if not compose_file.exists():
        raise DeployError(f"Missing docker compose file: {compose_file}")
    if shutil.which("docker") is None:
        raise DeployError("Docker is not installed or not available on PATH")

    subprocess.run(["/usr/bin/env", "docker", "--version"], cwd=project_dir, check=True)
    subprocess.run(["/usr/bin/env", "docker", "compose", "version"], cwd=project_dir, check=True)


def deploy(
    config: DeployConfig,
    project_dir: Path,
) -> DeployResult:
    """Write deployment config and run docker compose deployment."""
    if not (project_dir / "docker-compose.yml").exists():
        raise FileNotFoundError(f"Missing docker-compose.yml in {project_dir}")

    _validate_config(config)
    env_path = project_dir / DEFAULT_ENV_FILE
    env_path.write_text(build_env_content(config), encoding="utf-8")
    with suppress(OSError):
        env_path.chmod(0o600)

    subprocess.run(
        [
            "/usr/bin/env",
            "docker",
            "compose",
            "--env-file",
            ".env.production",
            "up",
            "-d",
            "--build",
        ],
        cwd=project_dir,
        check=True,
    )

    return DeployResult(env_path=env_path, commands=build_lifecycle_commands())


def _prompt_non_empty(prompt: str, default: str | None = None) -> str:
    """Prompt until a non-empty string is provided."""
    while True:
        suffix = f" [{default}]" if default is not None else ""
        value = input(f"{prompt}{suffix}: ").strip()
        if value:
            return value
        if default is not None:
            return default
        print("Value cannot be empty.")


def _prompt_host_port(default: int = DEFAULT_HOST_PORT) -> int:
    """Prompt for a valid host port."""
    while True:
        raw = input(f"Host port for AgBlogger [{default}]: ").strip()
        if not raw:
            return default
        if raw.isdigit():
            value = int(raw)
            if 1 <= value <= 65535:
                return value
        print("Please enter a valid port in range 1-65535.")


def _prompt_secret_key() -> str:
    """Prompt for secret key or auto-generate one."""
    secret_key = getpass.getpass(
        "SECRET_KEY (leave blank to auto-generate a random value): "
    ).strip()
    if not secret_key:
        generated = secrets.token_urlsafe(64)
        print("Generated SECRET_KEY automatically.")
        return generated

    if len(secret_key) < MIN_SECRET_KEY_LENGTH:
        print(f"SECRET_KEY must be at least {MIN_SECRET_KEY_LENGTH} characters.")
        return _prompt_secret_key()
    return secret_key


def _prompt_password() -> str:
    """Prompt for admin password with confirmation."""
    while True:
        password = getpass.getpass("Admin password: ").strip()
        if len(password) < MIN_ADMIN_PASSWORD_LENGTH:
            print(f"Password must be at least {MIN_ADMIN_PASSWORD_LENGTH} characters.")
            continue
        confirmation = getpass.getpass("Confirm admin password: ").strip()
        if password != confirmation:
            print("Passwords do not match.")
            continue
        return password


def collect_config() -> DeployConfig:
    """Collect interactive production settings from the user."""
    print("Enter production configuration values.")
    print("Trusted hosts should include every domain/IP used to access the app.")
    secret_key = _prompt_secret_key()
    admin_username = _prompt_non_empty("Admin username", default="admin")
    admin_password = _prompt_password()

    trusted_hosts: list[str] = []
    while not trusted_hosts:
        raw_hosts = input("Trusted hosts (comma-separated, required): ").strip()
        trusted_hosts = parse_csv_list(raw_hosts)
        if not trusted_hosts:
            print("Provide at least one trusted host.")

    proxy_ips = parse_csv_list(input("Trusted proxy IPs (comma-separated, optional): ").strip())
    host_port = _prompt_host_port()

    return DeployConfig(
        secret_key=secret_key,
        admin_username=admin_username,
        admin_password=admin_password,
        trusted_hosts=trusted_hosts,
        trusted_proxy_ips=proxy_ips,
        host_port=host_port,
    )


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Interactive end-to-end production deployment for AgBlogger.",
    )
    parser.add_argument(
        "--project-dir",
        type=Path,
        default=Path.cwd(),
        help="Project directory containing docker-compose.yml (default: current directory).",
    )
    return parser.parse_args()


def main() -> None:
    """Run interactive deployment workflow."""
    args = _parse_args()
    project_dir = args.project_dir.resolve()

    try:
        check_prerequisites(project_dir)
        config = collect_config()
        result = deploy(config=config, project_dir=project_dir)
    except (DeployError, FileNotFoundError) as exc:
        print(f"Deployment failed: {exc}")
        sys.exit(1)
    except subprocess.CalledProcessError as exc:
        print(f"Deployment failed: command returned exit code {exc.returncode}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nDeployment cancelled.")
        sys.exit(1)

    print("\nDeployment complete.")
    print(f"Environment file: {result.env_path}")
    print("Use these commands to manage the server:")
    print(f"  Start:  {result.commands['start']}")
    print(f"  Stop:   {result.commands['stop']}")
    print(f"  Status: {result.commands['status']}")
    print(f"Open the app at: http://<your-server-host>:{config.host_port}/login")


if __name__ == "__main__":
    main()
